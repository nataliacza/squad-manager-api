from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends
from pydantic import ValidationError
from sqlmodel import Session, select
from starlette.background import BackgroundTasks
from starlette.responses import JSONResponse

from app.db.dev_engine import get_session
from app.db.models.core_models import Member, Dog, Course
from app.helpers.autogenerated_courses import generate_courses
from app.schemas.courses import (CourseReadDto, UpdateCourseDto)
from app.schemas.members import (MemberResponseDto, CreateMemberDto, MemberListViewDto, MemberDetailsReadDto,
                                 UpdateMemberDetailsDto)

member_router = APIRouter()


@member_router.post(path="/",
                    response_model=MemberResponseDto,
                    summary="Add new member",
                    status_code=201,
                    responses={201: {"description": "Created"},
                               401: {"description": "Unauthorized"},
                               400: {"description": "Bad Request"},
                               405: {"description": "Method Not Allowed"}})
async def add_member(*, member_details: CreateMemberDto, session: Session = Depends(get_session),
                     background_tasks: BackgroundTasks):
    try:
        new_member = Member.from_orm(member_details)
        session.add(new_member)
        session.commit()
        session.refresh(new_member)

        background_tasks.add_task(generate_courses, new_member.id)

        return new_member

    except ValidationError as error:
        return error


@member_router.get(path="/",
                   response_model=List[MemberListViewDto],
                   summary="Get all members with details",
                   status_code=200,
                   responses={200: {"description": "Successful operation"},
                              401: {"description": "Unauthorized"},
                              405: {"description": "Method Not Allowed"}})
async def get_all_members(session: Session = Depends(get_session)):
    members = session.exec(select(Member)).all()
    return members


@member_router.get(path="/{member_id}/details",
                   response_model=MemberDetailsReadDto,
                   summary="Get member by id",
                   status_code=200,
                   responses={200: {"description": "Successful operation"},
                              401: {"description": "Unauthorized"},
                              404: {"description": "Not Found"},
                              405: {"description": "Method Not Allowed"}})
async def get_member_details(member_id: UUID, session: Session = Depends(get_session)):
    get_member = session.get(Member, member_id)

    if get_member:
        return get_member

    return JSONResponse(status_code=404, content={"description": "Id Not Found"})


@member_router.delete(path="/{member_id}",
                      summary="Delete member",
                      description="On deletion, all assigned courses will be removed. \
               Unable to delete, if has any Dogs assigned.",
                      status_code=204,
                      responses={204: {"description": "No content"},
                                 401: {"description": "Unauthorized"},
                                 404: {"description": "Not Found"},
                                 405: {"description": "Method Not Allowed"},
                                 409: {"description": "Conflict"}})
async def delete_member(member_id: UUID, session: Session = Depends(get_session)):
    get_member = session.get(Member, member_id)

    if get_member:
        get_dog = session.exec(select(Dog).where(Dog.owner_id == get_member.id)).first()
        if get_dog:
            return JSONResponse(status_code=409,
                                content={"description": "Unable to proceed. Dog assigned to Member"})
        session.delete(get_member)
        session.commit()
        return {}

    return JSONResponse(status_code=404, content={"description": "Id Not Found"})


@member_router.put(path="/{member_id}/details",
                   response_model=MemberResponseDto,
                   summary="Update member details",
                   status_code=200,
                   responses={200: {"description": "Successful operation"},
                              401: {"description": "Unauthorized"},
                              404: {"description": "Not Found"},
                              405: {"description": "Method Not Allowed"}})
async def update_member_details(*, member_id: UUID, update_member: UpdateMemberDetailsDto,
                                session: Session = Depends(get_session)):
    get_member = session.get(Member, member_id)

    if get_member:
        try:
            new_data = update_member.dict()
            for key, value in new_data.items():
                setattr(get_member, key, value)
            session.add(get_member)
            session.commit()
            session.refresh(get_member)

            return get_member

        except ValidationError as error:
            return error

    return JSONResponse(status_code=404, content={"description": "Id Not Found"})


@member_router.patch(path="/{member_id}/courses/{course_id}",
                     response_model=CourseReadDto,
                     summary="Update single course",
                     status_code=200,
                     responses={200: {"description": "Successful operation"},
                                401: {"description": "Unauthorized"},
                                404: {"description": "Not Found"},
                                405: {"description": "Method Not Allowed"}})
async def update_course_details(*, member_id: UUID, course_id: UUID, update_course: UpdateCourseDto,
                                session: Session = Depends(get_session)):
    get_course = session.exec(select(Course)
                              .where(Course.member_id == member_id)
                              .where(Course.id == course_id)).first()

    if get_course:
        try:
            new_course_data = update_course.dict(exclude_unset=True)
            for key, value in new_course_data.items():
                setattr(get_course, key, value)
            session.add(get_course)
            session.commit()
            session.refresh(get_course)
            return get_course

        except ValidationError as error:
            return error

    return JSONResponse(status_code=404, content={"description": "Course Not Found"})


@member_router.get(path="/{member_id}/courses",
                   response_model=List[CourseReadDto],
                   summary="Get member course list",
                   status_code=200,
                   responses={200: {"description": "Successful operation"},
                              401: {"description": "Unauthorized"},
                              404: {"description": "Not Found"},
                              405: {"description": "Method Not Allowed"}})
async def get_member_courses(member_id: UUID, session: Session = Depends(get_session)):
    get_member = session.get(Member, member_id)

    if get_member:
        courses = session.exec(select(Course).where(Course.member_id == member_id)).all()
        return courses

    return JSONResponse(status_code=404, content={"description": "Id Not Found"})
